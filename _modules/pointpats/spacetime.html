<!DOCTYPE html>

<html lang="en" data-content_root="../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>pointpats.spacetime &#8212; pointpats v2.3.0 Manual</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=fa44fd50" />
    <link rel="stylesheet" type="text/css" href="../../_static/bootstrap-sphinx.css?v=9afac83c" />
    <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/pysal-styles.css?v=f8dcc4ae" />
    <script src="../../_static/documentation_options.js?v=c3c8ae58"></script>
    <script src="../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="icon" href="../../_static/pysal_favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
<meta charset='utf-8'>
<meta http-equiv='X-UA-Compatible' content='IE=edge,chrome=1'>
<meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1'>
<meta name="apple-mobile-web-app-capable" content="yes">
<script type="text/javascript" src="../../_static/js/jquery-1.12.4.min.js"></script>
<script type="text/javascript" src="../../_static/js/jquery-fix.js"></script>
<script type="text/javascript" src="../../_static/bootstrap-3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="../../_static/bootstrap-sphinx.js"></script>

  </head><body>

  <div id="navbar" class="navbar navbar-default navbar-fixed-top">
    <div class="container">
      <div class="navbar-header">
        <!-- .btn-navbar is used as the toggle for collapsed navbar content -->
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".nav-collapse">
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="../../index.html">
          pointpats</a>
        <span class="navbar-text navbar-version pull-left"><b>2.3.0</b></span>
      </div>

        <div class="collapse navbar-collapse nav-collapse">
          <ul class="nav navbar-nav">
            
                <li><a href="../../installation.html">Installation</a></li>
                <li><a href="../../api.html">API</a></li>
                <li><a href="../../references.html">References</a></li>
            
            
              <li class="dropdown globaltoc-container">
  <a role="button"
     id="dLabelGlobalToc"
     data-toggle="dropdown"
     data-target="#"
     href="../../index.html">Site <b class="caret"></b></a>
  <ul class="dropdown-menu globaltoc"
      role="menu"
      aria-labelledby="dLabelGlobalToc"><p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#installing-released-version">Installing released version</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../installation.html#installing-development-version">Installing development version</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#point-pattern">Point Pattern</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#point-processes">Point Processes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#centrography">Centrography</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#density">Density</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#quadrat-based-statistics">Quadrat Based Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#distance-based-statistics">Distance Based Statistics</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#window-functions">Window functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#random-distributions">Random distributions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#space-time-interaction-tests">Space-Time Interaction Tests</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../api.html#visualization">Visualization</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">References</a></li>
</ul>
</ul>
</li>
              
                <li class="dropdown">
  <a role="button"
     id="dLabelLocalToc"
     data-toggle="dropdown"
     data-target="#"
     href="#">Page <b class="caret"></b></a>
  <ul class="dropdown-menu localtoc"
      role="menu"
      aria-labelledby="dLabelLocalToc"></ul>
</li>
              
            
            
            
            
            
          </ul>

          
            
<form class="navbar-form navbar-right" action="../../search.html" method="get">
 <div class="form-group">
  <input type="text" name="q" class="form-control" placeholder="Search" />
 </div>
  <input type="hidden" name="check_keywords" value="yes" />
  <input type="hidden" name="area" value="default" />
</form>
          
        </div>
    </div>
  </div>

<div class="container">
  <div class="row">
    <div class="body col-md-12 content" role="main">
      
  <h1>Source code for pointpats.spacetime</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Methods for identifying space-time interaction in spatio-temporal event</span>
<span class="sd">data.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="p">(</span>
    <span class="s2">&quot;Eli Knaap &lt;eknaap@sdsu.edu&gt;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Nicholas Malizia &lt;nmalizia@asu.edu&gt;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Sergio J. Rey &lt;srey@sdsu.edu&gt;&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Philip Stephens &lt;philip.stephens@asu.edu&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;SpaceTimeEvents&quot;</span><span class="p">,</span>
    <span class="s2">&quot;knox&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mantel&quot;</span><span class="p">,</span>
    <span class="s2">&quot;jacquez&quot;</span><span class="p">,</span>
    <span class="s2">&quot;modified_knox&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Knox&quot;</span><span class="p">,</span>
    <span class="s2">&quot;KnoxLocal&quot;</span><span class="p">,</span>
<span class="p">]</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">date</span>
<span class="kn">from</span> <span class="nn">warnings</span> <span class="kn">import</span> <span class="n">warn</span>

<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">import</span> <span class="nn">libpysal</span> <span class="k">as</span> <span class="nn">lps</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">stats</span>
<span class="kn">from</span> <span class="nn">libpysal</span> <span class="kn">import</span> <span class="n">cg</span>
<span class="kn">from</span> <span class="nn">libpysal.graph</span> <span class="kn">import</span> <span class="n">Graph</span>
<span class="kn">from</span> <span class="nn">pandas.api.types</span> <span class="kn">import</span> <span class="n">is_numeric_dtype</span>
<span class="kn">from</span> <span class="nn">scipy.spatial</span> <span class="kn">import</span> <span class="n">KDTree</span>
<span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">hypergeom</span><span class="p">,</span> <span class="n">poisson</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">LineString</span>


<div class="viewcode-block" id="SpaceTimeEvents">
<a class="viewcode-back" href="../../generated/pointpats.SpaceTimeEvents.html#pointpats.SpaceTimeEvents">[docs]</a>
<span class="k">class</span> <span class="nc">SpaceTimeEvents</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Method for reformatting event data stored in a shapefile for use in</span>
<span class="sd">    calculating metrics of spatio-temporal interaction.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    path            : string</span>
<span class="sd">                      the path to the appropriate shapefile, including the</span>
<span class="sd">                      file name and extension</span>
<span class="sd">    time            : string</span>
<span class="sd">                      column header in the DBF file indicating the column</span>
<span class="sd">                      containing the time stamp.</span>
<span class="sd">    infer_timestamp : bool, optional</span>
<span class="sd">                      if the column containing the timestamp is formatted as</span>
<span class="sd">                      calendar dates, try to coerce them into Python datetime</span>
<span class="sd">                      objects (the default is False).</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    n               : int</span>
<span class="sd">                      number of events.</span>
<span class="sd">    x               : array</span>
<span class="sd">                      (n, 1), array of the x coordinates for the events.</span>
<span class="sd">    y               : array</span>
<span class="sd">                      (n, 1), array of the y coordinates for the events.</span>
<span class="sd">    t               : array</span>
<span class="sd">                      (n, 1), array of the temporal coordinates for the events.</span>
<span class="sd">    space           : array</span>
<span class="sd">                      (n, 2), array of the spatial coordinates (x,y) for the</span>
<span class="sd">                      events.</span>
<span class="sd">    time            : array</span>
<span class="sd">                      (n, 2), array of the temporal coordinates (t,1) for the</span>
<span class="sd">                      events, the second column is a vector of ones.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    Read in the example shapefile data, ensuring to omit the file</span>
<span class="sd">    extension. In order to successfully create the event data the .dbf file</span>
<span class="sd">    associated with the shapefile should have a column of values that are a</span>
<span class="sd">    timestamp for the events. This timestamp may be a numerical value</span>
<span class="sd">    or a date. Date inference was added in version 1.6.</span>

<span class="sd">    &gt;&gt;&gt; import libpysal as lps</span>
<span class="sd">    &gt;&gt;&gt; path = lps.examples.get_path(&quot;burkitt.shp&quot;)</span>
<span class="sd">    &gt;&gt;&gt; from pointpats import SpaceTimeEvents</span>

<span class="sd">    Create an instance of SpaceTimeEvents from a shapefile, where the</span>
<span class="sd">    temporal information is stored in a column named &quot;T&quot;.</span>

<span class="sd">    &gt;&gt;&gt; events = SpaceTimeEvents(path,&#39;T&#39;)</span>

<span class="sd">    See how many events are in the instance.</span>

<span class="sd">    &gt;&gt;&gt; events.n</span>
<span class="sd">    188</span>

<span class="sd">    Check the spatial coordinates of the first event.</span>

<span class="sd">    &gt;&gt;&gt; events.space[0]</span>
<span class="sd">    array([300., 302.])</span>

<span class="sd">    Check the time of the first event.</span>

<span class="sd">    &gt;&gt;&gt; events.t[0]</span>
<span class="sd">    array([413.])</span>

<span class="sd">    Calculate the time difference between the first two events.</span>

<span class="sd">    &gt;&gt;&gt; events.t[1] - events.t[0]</span>
<span class="sd">    array([59.])</span>

<span class="sd">    New, in 1.6, date support:</span>
<span class="sd">    Now, create an instance of SpaceTimeEvents from a shapefile, where the</span>
<span class="sd">    temporal information is stored in a column named &quot;DATE&quot;.</span>

<span class="sd">    &gt;&gt;&gt; events = SpaceTimeEvents(path,&#39;DATE&#39;)</span>

<span class="sd">    See how many events are in the instance.</span>

<span class="sd">    &gt;&gt;&gt; events.n</span>
<span class="sd">    188</span>

<span class="sd">    Check the spatial coordinates of the first event.</span>

<span class="sd">    &gt;&gt;&gt; events.space[0]</span>
<span class="sd">    array([300., 302.])</span>

<span class="sd">    Check the time of the first event. Note that this value is equivalent to</span>
<span class="sd">    413 days after January 1, 1900.</span>

<span class="sd">    &gt;&gt;&gt; events.t[0][0]</span>
<span class="sd">    datetime.date(1901, 2, 16)</span>

<span class="sd">    Calculate the time difference between the first two events.</span>

<span class="sd">    &gt;&gt;&gt; (events.t[1][0] - events.t[0][0]).days</span>
<span class="sd">    59</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="SpaceTimeEvents.__init__">
<a class="viewcode-back" href="../../generated/pointpats.SpaceTimeEvents.html#pointpats.SpaceTimeEvents.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">time_col</span><span class="p">,</span> <span class="n">infer_timestamp</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="n">lps</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">head</span><span class="p">,</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="n">dbf_tail</span> <span class="o">=</span> <span class="n">tail</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.dbf&quot;</span>
        <span class="n">dbf</span> <span class="o">=</span> <span class="n">lps</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="n">lps</span><span class="o">.</span><span class="n">examples</span><span class="o">.</span><span class="n">get_path</span><span class="p">(</span><span class="n">dbf_tail</span><span class="p">))</span>

        <span class="c1"># extract the spatial coordinates from the shapefile</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">shp</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">coords</span> <span class="ow">in</span> <span class="n">shp</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">=</span> <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shp</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">space</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>

        <span class="c1"># extract the temporal information from the database</span>
        <span class="k">if</span> <span class="n">infer_timestamp</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">dbf</span><span class="o">.</span><span class="n">by_col</span><span class="p">(</span><span class="n">time_col</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">date</span><span class="p">):</span>
                <span class="n">day1</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                <span class="n">col</span> <span class="o">=</span> <span class="p">[(</span><span class="n">d</span> <span class="o">-</span> <span class="n">day1</span><span class="p">)</span><span class="o">.</span><span class="n">days</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">col</span><span class="p">]</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;Unable to parse your time column as Python datetime </span><span class="se">\</span>
<span class="s2">                      objects, proceeding as integers.&quot;</span>
                <span class="p">)</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dbf</span><span class="o">.</span><span class="n">by_col</span><span class="p">(</span><span class="n">time_col</span><span class="p">))</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">t</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>

        <span class="c1"># close open objects</span>
        <span class="n">dbf</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="n">shp</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>
</div>



<span class="k">def</span> <span class="nf">knox</span><span class="p">(</span><span class="n">s_coords</span><span class="p">,</span> <span class="n">t_coords</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="mi">99</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Knox test for spatio-temporal interaction. :cite:`Knox:1964`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s_coords        : array</span>
<span class="sd">                      (n, 2), spatial coordinates.</span>
<span class="sd">    t_coords        : array</span>
<span class="sd">                      (n, 1), temporal coordinates.</span>
<span class="sd">    delta           : float</span>
<span class="sd">                      threshold for proximity in space.</span>
<span class="sd">    tau             : float</span>
<span class="sd">                      threshold for proximity in time.</span>
<span class="sd">    permutations    : int, optional</span>
<span class="sd">                      the number of permutations used to establish pseudo-</span>
<span class="sd">                      significance (the default is 99).</span>
<span class="sd">    debug           : bool, optional</span>
<span class="sd">                      if true, debugging information is printed (the default is</span>
<span class="sd">                      False).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    knox_result     : dictionary</span>
<span class="sd">                      contains the statistic (stat) for the test and the</span>
<span class="sd">                      associated p-value (pvalue).</span>
<span class="sd">    stat            : float</span>
<span class="sd">                      value of the knox test for the dataset.</span>
<span class="sd">    pvalue          : float</span>
<span class="sd">                      pseudo p-value associated with the statistic.</span>
<span class="sd">    counts          : int</span>
<span class="sd">                      count of space time neighbors.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import libpysal as lps</span>
<span class="sd">    &gt;&gt;&gt; from pointpats import SpaceTimeEvents, knox</span>

<span class="sd">    Read in the example data and create an instance of SpaceTimeEvents.</span>

<span class="sd">    &gt;&gt;&gt; path = lps.examples.get_path(&quot;burkitt.shp&quot;)</span>
<span class="sd">    &gt;&gt;&gt; events = SpaceTimeEvents(path,&#39;T&#39;)</span>

<span class="sd">    Set the random seed generator. This is used by the permutation based</span>
<span class="sd">    inference to replicate the pseudo-significance of our example results -</span>
<span class="sd">    the end-user will normally omit this step.</span>

<span class="sd">    &gt;&gt;&gt; np.random.seed(100)</span>

<span class="sd">    Run the Knox test with distance and time thresholds of 20 and 5,</span>
<span class="sd">    respectively. This counts the events that are closer than 20 units in</span>
<span class="sd">    space, and 5 units in time.</span>

<span class="sd">    &gt;&gt;&gt; result = knox(events.space, events.t, delta=20, tau=5, permutations=99)</span>

<span class="sd">    Next, we examine the results. First, we call the statistic from the</span>
<span class="sd">    results dictionary. This reports that there are 13 events close</span>
<span class="sd">    in both space and time, according to our threshold definitions.</span>

<span class="sd">    &gt;&gt;&gt; result[&#39;stat&#39;] == 13</span>
<span class="sd">    True</span>

<span class="sd">    Next, we look at the pseudo-significance of this value, calculated by</span>
<span class="sd">    permuting the timestamps and rerunning the statistics. In this case,</span>
<span class="sd">    the results indicate there is likely no space-time interaction between</span>
<span class="sd">    the events.</span>

<span class="sd">    &gt;&gt;&gt; print(&quot;%2.2f&quot;%result[&#39;pvalue&#39;])</span>
<span class="sd">    0.17</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;This function is deprecated. Use Knox&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>

    <span class="c1"># Do a kdtree on space first as the number of ties (identical points) is</span>
    <span class="c1"># likely to be lower for space than time.</span>

    <span class="n">kd_s</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">KDTree</span><span class="p">(</span><span class="n">s_coords</span><span class="p">)</span>
    <span class="n">neigh_s</span> <span class="o">=</span> <span class="n">kd_s</span><span class="o">.</span><span class="n">query_pairs</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
    <span class="n">tau2</span> <span class="o">=</span> <span class="n">tau</span> <span class="o">*</span> <span class="n">tau</span>
    <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">neigh_s</span><span class="p">))</span>

    <span class="c1"># For the neighboring pairs in space, determine which are also time</span>
    <span class="c1"># neighbors</span>

    <span class="n">d_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_coords</span><span class="p">[</span><span class="n">ids</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">t_coords</span><span class="p">[</span><span class="n">ids</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]])</span> <span class="o">**</span> <span class="mi">2</span>
    <span class="n">n_st</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">d_t</span> <span class="o">&lt;=</span> <span class="n">tau2</span><span class="p">)</span>

    <span class="n">knox_result</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stat&quot;</span><span class="p">:</span> <span class="n">n_st</span><span class="p">[</span><span class="mi">0</span><span class="p">]}</span>

    <span class="k">if</span> <span class="n">permutations</span><span class="p">:</span>
        <span class="n">joint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">permutations</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">permutations</span><span class="p">):</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">t_coords</span><span class="p">)</span>
            <span class="n">d_t</span> <span class="o">=</span> <span class="p">(</span><span class="n">t_coords</span><span class="p">[</span><span class="n">ids</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">t_coords</span><span class="p">[</span><span class="n">ids</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]])</span> <span class="o">**</span> <span class="mi">2</span>
            <span class="n">joint</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">d_t</span> <span class="o">&lt;=</span> <span class="n">tau2</span><span class="p">)</span>

        <span class="n">larger</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">joint</span> <span class="o">&gt;=</span> <span class="n">n_st</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">permutations</span> <span class="o">-</span> <span class="n">larger</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">larger</span><span class="p">:</span>
            <span class="n">larger</span> <span class="o">=</span> <span class="n">permutations</span> <span class="o">-</span> <span class="n">larger</span>
        <span class="n">p_sim</span> <span class="o">=</span> <span class="p">(</span><span class="n">larger</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">permutations</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="n">knox_result</span><span class="p">[</span><span class="s2">&quot;pvalue&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_sim</span>
    <span class="k">return</span> <span class="n">knox_result</span>


<div class="viewcode-block" id="mantel">
<a class="viewcode-back" href="../../generated/pointpats.mantel.html#pointpats.mantel">[docs]</a>
<span class="k">def</span> <span class="nf">mantel</span><span class="p">(</span>
    <span class="n">s_coords</span><span class="p">,</span> <span class="n">t_coords</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="mi">99</span><span class="p">,</span> <span class="n">scon</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">spow</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">tcon</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">tpow</span><span class="o">=-</span><span class="mf">1.0</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Standardized Mantel test for spatio-temporal interaction. :cite:`Mantel:1967`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s_coords        : array</span>
<span class="sd">                      (n, 2), spatial coordinates.</span>
<span class="sd">    t_coords        : array</span>
<span class="sd">                      (n, 1), temporal coordinates.</span>
<span class="sd">    permutations    : int, optional</span>
<span class="sd">                      the number of permutations used to establish pseudo-</span>
<span class="sd">                      significance (the default is 99).</span>
<span class="sd">    scon            : float, optional</span>
<span class="sd">                      constant added to spatial distances (the default is 1.0).</span>
<span class="sd">    spow            : float, optional</span>
<span class="sd">                      value for power transformation for spatial distances</span>
<span class="sd">                      (the default is -1.0).</span>
<span class="sd">    tcon            : float, optional</span>
<span class="sd">                      constant added to temporal distances (the default is 1.0).</span>
<span class="sd">    tpow            : float, optional</span>
<span class="sd">                      value for power transformation for temporal distances</span>
<span class="sd">                      (the default is -1.0).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    mantel_result   : dictionary</span>
<span class="sd">                      contains the statistic (stat) for the test and the</span>
<span class="sd">                      associated p-value (pvalue).</span>
<span class="sd">    stat            : float</span>
<span class="sd">                      value of the knox test for the dataset.</span>
<span class="sd">    pvalue          : float</span>
<span class="sd">                      pseudo p-value associated with the statistic.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import libpysal as lps</span>
<span class="sd">    &gt;&gt;&gt; from pointpats import SpaceTimeEvents, mantel</span>

<span class="sd">    Read in the example data and create an instance of SpaceTimeEvents.</span>

<span class="sd">    &gt;&gt;&gt; path = lps.examples.get_path(&quot;burkitt.shp&quot;)</span>
<span class="sd">    &gt;&gt;&gt; events = SpaceTimeEvents(path,&#39;T&#39;)</span>

<span class="sd">    Set the random seed generator. This is used by the permutation based</span>
<span class="sd">    inference to replicate the pseudo-significance of our example results -</span>
<span class="sd">    the end-user will normally omit this step.</span>

<span class="sd">    &gt;&gt;&gt; np.random.seed(100)</span>

<span class="sd">    The standardized Mantel test is a measure of matrix correlation between</span>
<span class="sd">    the spatial and temporal distance matrices of the event dataset. The</span>
<span class="sd">    following example runs the standardized Mantel test without a constant</span>
<span class="sd">    or transformation; however, as recommended by :cite:`Mantel:1967`, these</span>
<span class="sd">    should be added by the user. This can be done by adjusting the constant</span>
<span class="sd">    and power parameters.</span>

<span class="sd">    &gt;&gt;&gt; result = mantel(events.space, events.t, 99, scon=1.0, spow=-1.0, tcon=1.0, tpow=-1.0)</span>

<span class="sd">    Next, we examine the result of the test.</span>

<span class="sd">    &gt;&gt;&gt; print(&quot;%6.6f&quot;%result[&#39;stat&#39;])</span>
<span class="sd">    0.048368</span>

<span class="sd">    Finally, we look at the pseudo-significance of this value, calculated by</span>
<span class="sd">    permuting the timestamps and rerunning the statistic for each of the 99</span>
<span class="sd">    permutations. According to these parameters, the results indicate</span>
<span class="sd">    space-time interaction between the events.</span>

<span class="sd">    &gt;&gt;&gt; print(&quot;%2.2f&quot;%result[&#39;pvalue&#39;])</span>
<span class="sd">    0.01</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">t_coords</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s_coords</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="c1"># calculate the spatial and temporal distance matrices for the events</span>
    <span class="n">distmat</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">timemat</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="c1"># calculate the transformed standardized statistic</span>
    <span class="n">timevec</span> <span class="o">=</span> <span class="p">(</span><span class="n">timemat</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">timemat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">+</span> <span class="n">tcon</span><span class="p">)</span> <span class="o">**</span> <span class="n">tpow</span>
    <span class="n">distvec</span> <span class="o">=</span> <span class="p">(</span><span class="n">distmat</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">distmat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">+</span> <span class="n">scon</span><span class="p">)</span> <span class="o">**</span> <span class="n">spow</span>
    <span class="n">stat</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">pearsonr</span><span class="p">(</span><span class="n">timevec</span><span class="p">,</span> <span class="n">distvec</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># return the results (if no inference)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">permutations</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stat</span>

    <span class="c1"># loop for generating a random distribution to assess significance</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">permutations</span><span class="p">):</span>
        <span class="n">trand</span> <span class="o">=</span> <span class="n">_shuffle_matrix</span><span class="p">(</span><span class="n">timemat</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
        <span class="n">timevec</span> <span class="o">=</span> <span class="p">(</span><span class="n">trand</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tril_indices</span><span class="p">(</span><span class="n">trand</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=-</span><span class="mi">1</span><span class="p">)]</span> <span class="o">+</span> <span class="n">tcon</span><span class="p">)</span> <span class="o">**</span> <span class="n">tpow</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">pearsonr</span><span class="p">(</span><span class="n">timevec</span><span class="p">,</span> <span class="n">distvec</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

    <span class="c1"># establish the pseudo significance of the observed statistic</span>
    <span class="n">distribution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
    <span class="n">greater</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater_equal</span><span class="p">(</span><span class="n">distribution</span><span class="p">,</span> <span class="n">stat</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">count_masked</span><span class="p">(</span><span class="n">greater</span><span class="p">)</span>
    <span class="n">pvalue</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">permutations</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># report the results</span>
    <span class="n">mantel_result</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stat&quot;</span><span class="p">:</span> <span class="n">stat</span><span class="p">,</span> <span class="s2">&quot;pvalue&quot;</span><span class="p">:</span> <span class="n">pvalue</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">mantel_result</span></div>



<div class="viewcode-block" id="jacquez">
<a class="viewcode-back" href="../../generated/pointpats.jacquez.html#pointpats.jacquez">[docs]</a>
<span class="k">def</span> <span class="nf">jacquez</span><span class="p">(</span><span class="n">s_coords</span><span class="p">,</span> <span class="n">t_coords</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="mi">99</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Jacquez k nearest neighbors test for spatio-temporal interaction.</span>
<span class="sd">    :cite:`Jacquez:1996`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s_coords        : array</span>
<span class="sd">                      (n, 2), spatial coordinates.</span>
<span class="sd">    t_coords        : array</span>
<span class="sd">                      (n, 1), temporal coordinates.</span>
<span class="sd">    k               : int</span>
<span class="sd">                      the number of nearest neighbors to be searched.</span>
<span class="sd">    permutations    : int, optional</span>
<span class="sd">                      the number of permutations used to establish pseudo-</span>
<span class="sd">                      significance (the default is 99).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    jacquez_result  : dictionary</span>
<span class="sd">                      contains the statistic (stat) for the test and the</span>
<span class="sd">                      associated p-value (pvalue).</span>
<span class="sd">    stat            : float</span>
<span class="sd">                      value of the Jacquez k nearest neighbors test for the</span>
<span class="sd">                      dataset.</span>
<span class="sd">    pvalue          : float</span>
<span class="sd">                      p-value associated with the statistic (normally</span>
<span class="sd">                      distributed with k-1 df).</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import libpysal as lps</span>
<span class="sd">    &gt;&gt;&gt; from pointpats import SpaceTimeEvents, jacquez</span>

<span class="sd">    Read in the example data and create an instance of SpaceTimeEvents.</span>

<span class="sd">    &gt;&gt;&gt; path = lps.examples.get_path(&quot;burkitt.shp&quot;)</span>
<span class="sd">    &gt;&gt;&gt; events = SpaceTimeEvents(path,&#39;T&#39;)</span>

<span class="sd">    The Jacquez test counts the number of events that are k nearest</span>
<span class="sd">    neighbors in both time and space. The following runs the Jacquez test</span>
<span class="sd">    on the example data and reports the resulting statistic. In this case,</span>
<span class="sd">    there are 12 instances where events are nearest neighbors in both space</span>
<span class="sd">    and time.</span>
<span class="sd">    # turning off as kdtree changes from scipy &lt; 0.12 return 13</span>

<span class="sd">    &gt;&gt;&gt; np.random.seed(100)</span>
<span class="sd">    &gt;&gt;&gt; result = jacquez(events.space, events.t ,k=3,permutations=99)</span>
<span class="sd">    &gt;&gt;&gt; print(result[&#39;stat&#39;])</span>
<span class="sd">    12</span>

<span class="sd">    The significance of this can be assessed by calling the p-</span>
<span class="sd">    value from the results dictionary, as shown below. Again, no</span>
<span class="sd">    space-time interaction is observed.</span>

<span class="sd">    &gt;&gt;&gt; result[&#39;pvalue&#39;] &lt; 0.01</span>
<span class="sd">    False</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">time</span> <span class="o">=</span> <span class="n">t_coords</span>
    <span class="n">space</span> <span class="o">=</span> <span class="n">s_coords</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>

    <span class="c1"># calculate the nearest neighbors in space and time separately</span>
    <span class="n">knnt</span> <span class="o">=</span> <span class="n">lps</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">KNN</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
    <span class="n">knns</span> <span class="o">=</span> <span class="n">lps</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">KNN</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">space</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

    <span class="n">nnt</span> <span class="o">=</span> <span class="n">knnt</span><span class="o">.</span><span class="n">neighbors</span>
    <span class="n">nns</span> <span class="o">=</span> <span class="n">knns</span><span class="o">.</span><span class="n">neighbors</span>
    <span class="n">knn_sum</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># determine which events are nearest neighbors in both space and time</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
        <span class="n">t_neighbors</span> <span class="o">=</span> <span class="n">nnt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">s_neighbors</span> <span class="o">=</span> <span class="n">nns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">check</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">t_neighbors</span><span class="p">)</span>
        <span class="n">inter</span> <span class="o">=</span> <span class="n">check</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">s_neighbors</span><span class="p">)</span>
        <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter</span><span class="p">)</span>
        <span class="n">knn_sum</span> <span class="o">+=</span> <span class="n">count</span>

    <span class="n">stat</span> <span class="o">=</span> <span class="n">knn_sum</span>

    <span class="c1"># return the results (if no inference)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">permutations</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stat</span>

    <span class="c1"># loop for generating a random distribution to assess significance</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">_p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">permutations</span><span class="p">):</span>
        <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">trand</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">time</span><span class="p">)</span>
        <span class="n">knnt</span> <span class="o">=</span> <span class="n">lps</span><span class="o">.</span><span class="n">weights</span><span class="o">.</span><span class="n">KNN</span><span class="o">.</span><span class="n">from_array</span><span class="p">(</span><span class="n">trand</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
        <span class="n">nnt</span> <span class="o">=</span> <span class="n">knnt</span><span class="o">.</span><span class="n">neighbors</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">t_neighbors</span> <span class="o">=</span> <span class="n">nnt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">s_neighbors</span> <span class="o">=</span> <span class="n">nns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">check</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">t_neighbors</span><span class="p">)</span>
            <span class="n">inter</span> <span class="o">=</span> <span class="n">check</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">s_neighbors</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">inter</span><span class="p">)</span>
            <span class="n">j</span> <span class="o">+=</span> <span class="n">count</span>

        <span class="n">dist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>

    <span class="c1"># establish the pseudo significance of the observed statistic</span>
    <span class="n">distribution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
    <span class="n">greater</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater_equal</span><span class="p">(</span><span class="n">distribution</span><span class="p">,</span> <span class="n">stat</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">count_masked</span><span class="p">(</span><span class="n">greater</span><span class="p">)</span>
    <span class="n">pvalue</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">permutations</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># report the results</span>
    <span class="n">jacquez_result</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stat&quot;</span><span class="p">:</span> <span class="n">stat</span><span class="p">,</span> <span class="s2">&quot;pvalue&quot;</span><span class="p">:</span> <span class="n">pvalue</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">jacquez_result</span></div>



<div class="viewcode-block" id="modified_knox">
<a class="viewcode-back" href="../../generated/pointpats.modified_knox.html#pointpats.modified_knox">[docs]</a>
<span class="k">def</span> <span class="nf">modified_knox</span><span class="p">(</span><span class="n">s_coords</span><span class="p">,</span> <span class="n">t_coords</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="mi">99</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Baker&#39;s modified Knox test for spatio-temporal interaction.</span>
<span class="sd">    :cite:`Baker:2004`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s_coords        : array</span>
<span class="sd">                      (n, 2), spatial coordinates.</span>
<span class="sd">    t_coords        : array</span>
<span class="sd">                      (n, 1), temporal coordinates.</span>
<span class="sd">    delta           : float</span>
<span class="sd">                      threshold for proximity in space.</span>
<span class="sd">    tau             : float</span>
<span class="sd">                      threshold for proximity in time.</span>
<span class="sd">    permutations    : int, optional</span>
<span class="sd">                      the number of permutations used to establish pseudo-</span>
<span class="sd">                      significance (the default is 99).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    modknox_result  : dictionary</span>
<span class="sd">                      contains the statistic (stat) for the test and the</span>
<span class="sd">                      associated p-value (pvalue).</span>
<span class="sd">    stat            : float</span>
<span class="sd">                      value of the modified knox test for the dataset.</span>
<span class="sd">    pvalue          : float</span>
<span class="sd">                      pseudo p-value associated with the statistic.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; import libpysal as lps</span>
<span class="sd">    &gt;&gt;&gt; from pointpats import SpaceTimeEvents, modified_knox</span>

<span class="sd">    Read in the example data and create an instance of SpaceTimeEvents.</span>

<span class="sd">    &gt;&gt;&gt; path = lps.examples.get_path(&quot;burkitt.shp&quot;)</span>
<span class="sd">    &gt;&gt;&gt; events = SpaceTimeEvents(path, &#39;T&#39;)</span>

<span class="sd">    Set the random seed generator. This is used by the permutation based</span>
<span class="sd">    inference to replicate the pseudo-significance of our example results -</span>
<span class="sd">    the end-user will normally omit this step.</span>

<span class="sd">    &gt;&gt;&gt; np.random.seed(100)</span>

<span class="sd">    Run the modified Knox test with distance and time thresholds of 20 and 5,</span>
<span class="sd">    respectively. This counts the events that are closer than 20 units in</span>
<span class="sd">    space, and 5 units in time.</span>

<span class="sd">    &gt;&gt;&gt; result = modified_knox(events.space, events.t, delta=20, tau=5, permutations=99)</span>

<span class="sd">    Next, we examine the results. First, we call the statistic from the</span>
<span class="sd">    results dictionary. This reports the difference between the observed</span>
<span class="sd">    and expected Knox statistic.</span>

<span class="sd">    &gt;&gt;&gt; print(&quot;%2.8f&quot; % result[&#39;stat&#39;])</span>
<span class="sd">    2.81016043</span>

<span class="sd">    Next, we look at the pseudo-significance of this value, calculated by</span>
<span class="sd">    permuting the timestamps and rerunning the statistics. In this case,</span>
<span class="sd">    the results indicate there is likely no space-time interaction.</span>

<span class="sd">    &gt;&gt;&gt; print(&quot;%2.2f&quot; % result[&#39;pvalue&#39;])</span>
<span class="sd">    0.11</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">s_coords</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">t_coords</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="c1"># calculate the spatial and temporal distance matrices for the events</span>
    <span class="n">sdistmat</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
    <span class="n">tdistmat</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">distance_matrix</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

    <span class="c1"># identify events within thresholds</span>
    <span class="n">spacmat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">spacbin</span> <span class="o">=</span> <span class="n">sdistmat</span> <span class="o">&lt;=</span> <span class="n">delta</span>
    <span class="n">spacmat</span> <span class="o">=</span> <span class="n">spacmat</span> <span class="o">*</span> <span class="n">spacbin</span>
    <span class="n">timemat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
    <span class="n">timebin</span> <span class="o">=</span> <span class="n">tdistmat</span> <span class="o">&lt;=</span> <span class="n">tau</span>
    <span class="n">timemat</span> <span class="o">=</span> <span class="n">timemat</span> <span class="o">*</span> <span class="n">timebin</span>

    <span class="c1"># calculate the observed (original) statistic</span>
    <span class="n">knoxmat</span> <span class="o">=</span> <span class="n">timemat</span> <span class="o">*</span> <span class="n">spacmat</span>
    <span class="n">obsstat</span> <span class="o">=</span> <span class="n">knoxmat</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">n</span>

    <span class="c1"># calculate the expectated value</span>
    <span class="n">ssumvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">spacbin</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">tsumvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">timebin</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
    <span class="n">expstat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ssumvec</span> <span class="o">*</span> <span class="n">tsumvec</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="c1"># calculate the modified stat</span>
    <span class="n">stat</span> <span class="o">=</span> <span class="p">(</span><span class="n">obsstat</span> <span class="o">-</span> <span class="p">(</span><span class="n">expstat</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)))</span> <span class="o">/</span> <span class="mf">2.0</span>

    <span class="c1"># return results (if no inference)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">permutations</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">stat</span>
    <span class="n">distribution</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># loop for generating a random distribution to assess significance</span>
    <span class="k">for</span> <span class="n">_p</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">permutations</span><span class="p">):</span>
        <span class="n">rtdistmat</span> <span class="o">=</span> <span class="n">_shuffle_matrix</span><span class="p">(</span><span class="n">tdistmat</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span>
        <span class="n">timemat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">timebin</span> <span class="o">=</span> <span class="n">rtdistmat</span> <span class="o">&lt;=</span> <span class="n">tau</span>
        <span class="n">timemat</span> <span class="o">=</span> <span class="n">timemat</span> <span class="o">*</span> <span class="n">timebin</span>

        <span class="c1"># calculate the observed knox again</span>
        <span class="n">knoxmat</span> <span class="o">=</span> <span class="n">timemat</span> <span class="o">*</span> <span class="n">spacmat</span>
        <span class="n">obsstat</span> <span class="o">=</span> <span class="n">knoxmat</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">-</span> <span class="n">n</span>

        <span class="c1"># calculate the expectated value again</span>
        <span class="n">ssumvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">spacbin</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">tsumvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="n">timebin</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">expstat</span> <span class="o">=</span> <span class="p">(</span><span class="n">ssumvec</span> <span class="o">*</span> <span class="n">tsumvec</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># calculate the modified stat</span>
        <span class="n">tempstat</span> <span class="o">=</span> <span class="p">(</span><span class="n">obsstat</span> <span class="o">-</span> <span class="p">(</span><span class="n">expstat</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mf">1.0</span><span class="p">)))</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="n">distribution</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tempstat</span><span class="p">)</span>

    <span class="c1"># establish the pseudo significance of the observed statistic</span>
    <span class="n">distribution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">distribution</span><span class="p">)</span>
    <span class="n">greater</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">masked_greater_equal</span><span class="p">(</span><span class="n">distribution</span><span class="p">,</span> <span class="n">stat</span><span class="p">)</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ma</span><span class="o">.</span><span class="n">count_masked</span><span class="p">(</span><span class="n">greater</span><span class="p">)</span>
    <span class="n">pvalue</span> <span class="o">=</span> <span class="p">(</span><span class="n">count</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">permutations</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">)</span>

    <span class="c1"># return results</span>
    <span class="n">modknox_result</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stat&quot;</span><span class="p">:</span> <span class="n">stat</span><span class="p">,</span> <span class="s2">&quot;pvalue&quot;</span><span class="p">:</span> <span class="n">pvalue</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">modknox_result</span></div>



<span class="k">def</span> <span class="nf">_shuffle_matrix</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Random permutation of rows and columns of a matrix</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    X   : array</span>
<span class="sd">          (k, k), array to be permuted.</span>
<span class="sd">    ids : array</span>
<span class="sd">          range (k, ).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        : array</span>
<span class="sd">          (k, k) with rows and columns randomly shuffled.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">X</span><span class="p">[</span><span class="n">ids</span><span class="p">,</span> <span class="p">:][:,</span> <span class="n">ids</span><span class="p">]</span>


<span class="k">def</span> <span class="nf">_knox</span><span class="p">(</span><span class="n">s_coords</span><span class="p">,</span> <span class="n">t_coords</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="mi">99</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Parameters</span>
<span class="sd">    ==========</span>

<span class="sd">    s_coords: array-like</span>
<span class="sd">        spatial coordinates</span>
<span class="sd">    t_coords: array-like</span>
<span class="sd">        temporal coordinates</span>
<span class="sd">    delta: float</span>
<span class="sd">        distance threshold</span>
<span class="sd">    tau: float</span>
<span class="sd">        temporal threshold</span>
<span class="sd">    permutations: int</span>
<span class="sd">        number of permutations</span>
<span class="sd">    keep: bool</span>
<span class="sd">        return values from permutations (default False)</span>


<span class="sd">    Returns</span>
<span class="sd">    =======</span>

<span class="sd">    summary table observed</span>
<span class="sd">    summary table h0</span>

<span class="sd">    ns</span>
<span class="sd">    nt</span>
<span class="sd">    nst</span>
<span class="sd">    n</span>
<span class="sd">    p-value</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">n</span> <span class="o">=</span> <span class="n">s_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">stree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">s_coords</span><span class="p">)</span>
    <span class="n">ttree</span> <span class="o">=</span> <span class="n">KDTree</span><span class="p">(</span><span class="n">t_coords</span><span class="p">)</span>
    <span class="n">sneighbors</span> <span class="o">=</span> <span class="n">stree</span><span class="o">.</span><span class="n">query_ball_tree</span><span class="p">(</span><span class="n">stree</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">delta</span><span class="p">)</span>
    <span class="n">sneighbors</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">set</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">([</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sneighbors</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">tneighbors</span> <span class="o">=</span> <span class="n">ttree</span><span class="o">.</span><span class="n">query_ball_tree</span><span class="p">(</span><span class="n">ttree</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="n">tau</span><span class="p">)</span>
    <span class="n">tneighbors</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">set</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">([</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">tneighbors</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># number of spatial neighbor pairs</span>
    <span class="n">ns</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="k">for</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">sneighbors</span><span class="p">])</span>  <span class="c1"># by i</span>

    <span class="n">NS</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span>  <span class="c1"># total</span>

    <span class="c1"># number of temporal neigbor pairs</span>
    <span class="n">nt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="k">for</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">tneighbors</span><span class="p">])</span>
    <span class="n">NT</span> <span class="o">=</span> <span class="n">nt</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="c1"># s-t neighbors (list of lists)</span>
    <span class="n">stneighbors</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">sneighbors_i</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">tneighbors_i</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sneighbors_i</span><span class="p">,</span> <span class="n">tneighbors_i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sneighbors</span><span class="p">,</span> <span class="n">tneighbors</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="c1"># number of spatio-temporal neigbor pairs</span>
    <span class="n">nst</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="k">for</span> <span class="n">neighbors</span> <span class="ow">in</span> <span class="n">stneighbors</span><span class="p">])</span>
    <span class="n">NST</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span>

    <span class="n">all_pairs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">neigh</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stneighbors</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neigh</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">all_pairs</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="nb">sorted</span><span class="p">((</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">))</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">neigh</span><span class="p">])</span>
    <span class="n">st_pairs</span> <span class="o">=</span> <span class="p">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">all_pairs</span><span class="p">}</span>

    <span class="c1"># ENST: expected number of spatio-temporal neighbors under HO</span>
    <span class="n">pairs</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">ENST</span> <span class="o">=</span> <span class="n">NS</span> <span class="o">*</span> <span class="n">NT</span> <span class="o">/</span> <span class="n">pairs</span>

    <span class="c1"># observed table</span>
    <span class="n">observed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

    <span class="n">NS_</span> <span class="o">=</span> <span class="n">NS</span> <span class="o">-</span> <span class="n">NST</span>  <span class="c1"># spatial only</span>
    <span class="n">NT_</span> <span class="o">=</span> <span class="n">NT</span> <span class="o">-</span> <span class="n">NST</span>  <span class="c1"># temporal only</span>

    <span class="n">observed</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">NST</span>
    <span class="n">observed</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">NS_</span>
    <span class="n">observed</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">NT_</span>
    <span class="n">observed</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pairs</span> <span class="o">-</span> <span class="n">NST</span> <span class="o">-</span> <span class="n">NS_</span> <span class="o">-</span> <span class="n">NT_</span>

    <span class="c1"># expected table</span>

    <span class="n">expected</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="n">expected</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ENST</span>
    <span class="n">expected</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">NS</span> <span class="o">-</span> <span class="n">expected</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">expected</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">NT</span> <span class="o">-</span> <span class="n">expected</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">expected</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pairs</span> <span class="o">-</span> <span class="n">expected</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="n">p_value_poisson</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">poisson</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">NST</span><span class="p">,</span> <span class="n">expected</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>

    <span class="n">results</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;ns&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;nt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nt</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;nst&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nst</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;pairs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pairs</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;expected&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">expected</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;observed&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">observed</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;p_value_poisson&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">p_value_poisson</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;st_pairs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">st_pairs</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;sneighbors&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sneighbors</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;tneighbors&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tneighbors</span>
    <span class="n">results</span><span class="p">[</span><span class="s2">&quot;stneighbors&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">stneighbors</span>

    <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">exceedence</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sneighbors</span><span class="p">)</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">ST</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">permutations</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">permutations</span><span class="p">):</span>
            <span class="n">st</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">rids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">ri</span> <span class="o">=</span> <span class="n">rids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">tni</span> <span class="o">=</span> <span class="n">tneighbors</span><span class="p">[</span><span class="n">ri</span><span class="p">]</span>
                <span class="n">rjs</span> <span class="o">=</span> <span class="p">[</span><span class="n">rids</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sneighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">sti</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">rjs</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">tni</span><span class="p">]</span>
                <span class="n">st</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sti</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">/=</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">st</span> <span class="o">&gt;=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;nst&quot;</span><span class="p">]:</span>
                <span class="n">exceedence</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
                <span class="n">ST</span><span class="p">[</span><span class="n">perm</span><span class="p">]</span> <span class="o">=</span> <span class="n">st</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;p_value_sim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">exceedence</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">permutations</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">results</span><span class="p">[</span><span class="s2">&quot;exceedence&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">exceedence</span>
        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;st_perm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ST</span>

    <span class="k">return</span> <span class="n">results</span>


<div class="viewcode-block" id="Knox">
<a class="viewcode-back" href="../../generated/pointpats.Knox.html#pointpats.Knox">[docs]</a>
<span class="k">class</span> <span class="nc">Knox</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Global Knox statistic for space-time interactions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s_coords: array-like</span>
<span class="sd">        spatial coordinates of point events</span>
<span class="sd">    t_coords: array-like</span>
<span class="sd">        temporal coordinates of point events (floats or ints, not dateTime)</span>
<span class="sd">    delta: float</span>
<span class="sd">        spatial threshold defining distance below which pairs are spatial</span>
<span class="sd">        neighbors</span>
<span class="sd">    tau: float</span>
<span class="sd">        temporal threshold defining distance below which pairs are temporal</span>
<span class="sd">        neighbors</span>
<span class="sd">    permutations: int</span>
<span class="sd">        number of random permutations for inference</span>
<span class="sd">    keep: bool</span>
<span class="sd">        whether to store realized values of the statistic under permutations</span>


<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    s_coords: array-like</span>
<span class="sd">        spatial coordinates of point events</span>
<span class="sd">    t_coords: array-like</span>
<span class="sd">        temporal coordinates of point events (floats or ints, not dateTime)</span>
<span class="sd">    delta: float</span>
<span class="sd">        spatial threshold defining distance below which pairs are spatial</span>
<span class="sd">        neighbors</span>
<span class="sd">    tau: float</span>
<span class="sd">        temporal threshold defining distance below which pairs are temporal</span>
<span class="sd">        neighbors</span>
<span class="sd">    permutations: int</span>
<span class="sd">        number of random permutations for inference</span>
<span class="sd">    keep: bool</span>
<span class="sd">        whether to store realized values of the statistic under permutations</span>
<span class="sd">    nst: int</span>
<span class="sd">        number of space-time pairs</span>
<span class="sd">    p_poisson: float</span>
<span class="sd">        Analytical p-value under Poisson assumption</span>
<span class="sd">    p_sim: float</span>
<span class="sd">        Pseudo p-value based on random permutations</span>
<span class="sd">    expected: array</span>
<span class="sd">        Two-by-two array with expected counts under the null of no space-time</span>
<span class="sd">        interactions. [[NST, NS_], [NT_, N__]] where NST is the expected number</span>
<span class="sd">        of space-time pairs, NS_ is the expected number of spatial (but not also</span>
<span class="sd">        temporal) pairs, NT_ is the number of expected temporal (but not also</span>
<span class="sd">        spatial pairs), N__ is the number of pairs that are neighor spatial or</span>
<span class="sd">        temporal neighbors.</span>
<span class="sd">    observed: array</span>
<span class="sd">        Same structure as expected with the observed pair classifications</span>
<span class="sd">    sim: array</span>
<span class="sd">        Global statistics from permutations (if keep=True)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Technical details can be found in :cite:`Rogerson:2001`</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import libpysal</span>
<span class="sd">    &gt;&gt;&gt; path = libpysal.examples.get_path(&#39;burkitt.shp&#39;)</span>
<span class="sd">    &gt;&gt;&gt; import geopandas</span>
<span class="sd">    &gt;&gt;&gt; df = geopandas.read_file(path)</span>
<span class="sd">    &gt;&gt;&gt; from pointpats.spacetime import Knox</span>
<span class="sd">    &gt;&gt;&gt; global_knox = Knox(df[[&#39;X&#39;, &#39;Y&#39;]], df[[&quot;T&quot;]], delta=20, tau=5)</span>
<span class="sd">    &gt;&gt;&gt; global_knox.statistic_</span>
<span class="sd">    13</span>
<span class="sd">    &gt;&gt;&gt; global_knox.p_poisson</span>
<span class="sd">    0.14624558197140414</span>
<span class="sd">    &gt;&gt;&gt; global_knox.observed</span>
<span class="sd">    array([[1.300e+01, 3.416e+03],</span>
<span class="sd">           [3.900e+01, 1.411e+04]])</span>
<span class="sd">    &gt;&gt;&gt; global_knox.expected</span>
<span class="sd">    array([[1.01438161e+01, 3.41885618e+03],</span>
<span class="sd">           [4.18561839e+01, 1.41071438e+04]])</span>
<span class="sd">    &gt;&gt;&gt; hasattr(global_knox, &#39;sim&#39;)</span>
<span class="sd">    False</span>
<span class="sd">    &gt;&gt;&gt; import numpy</span>
<span class="sd">    &gt;&gt;&gt; numpy.random.seed(12345)</span>
<span class="sd">    &gt;&gt;&gt; global_knox = Knox(df[[&#39;X&#39;, &#39;Y&#39;]], df[[&quot;T&quot;]], delta=20, tau=5, keep=True)</span>
<span class="sd">    &gt;&gt;&gt; hasattr(global_knox, &#39;sim&#39;)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; global_knox.p_sim</span>
<span class="sd">    0.21</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Knox.__init__">
<a class="viewcode-back" href="../../generated/pointpats.Knox.html#pointpats.Knox.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s_coords</span><span class="p">,</span> <span class="n">t_coords</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="mi">99</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_coords</span> <span class="o">=</span> <span class="n">s_coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_coords</span> <span class="o">=</span> <span class="n">t_coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="n">tau</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">permutations</span> <span class="o">=</span> <span class="n">permutations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep</span> <span class="o">=</span> <span class="n">keep</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">_knox</span><span class="p">(</span><span class="n">s_coords</span><span class="p">,</span> <span class="n">t_coords</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">permutations</span><span class="p">,</span> <span class="n">keep</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nst</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s2">&quot;nst&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_sim</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;p_value_sim&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sim</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;st_perm&quot;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">p_poisson</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;p_value_poisson&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observed</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;observed&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expected</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;expected&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">statistic_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nst</span></div>


<div class="viewcode-block" id="Knox.from_dataframe">
<a class="viewcode-back" href="../../generated/pointpats.Knox.html#pointpats.Knox.from_dataframe">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dataframe</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">dataframe</span><span class="p">,</span>
        <span class="n">time_col</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">delta</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">tau</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">permutations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">99</span><span class="p">,</span>
        <span class="n">keep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute a Knox statistic from a dataframe of Point observations</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataframe : geopandas.GeoDataFrame</span>
<span class="sd">            geodataframe holding observations. Should be in a projected coordinate</span>
<span class="sd">            system with geometries stored as Point</span>
<span class="sd">        time_col : str</span>
<span class="sd">            column in the dataframe storing the time values (integer coordinate)</span>
<span class="sd">            for each observation. For example if the observations are stored with</span>
<span class="sd">            a timestamp, the time_col should be converted to a series of integers</span>
<span class="sd">            representing, e.g. hours, days, seconds, etc.</span>
<span class="sd">        delta : int</span>
<span class="sd">            delta parameter defining the spatial neighbor threshold measured in the</span>
<span class="sd">            same units as the dataframe CRS</span>
<span class="sd">        tau : int</span>
<span class="sd">            tau parameter defining the temporal neihgbor threshold (in the units</span>
<span class="sd">            measured by `time_col`)</span>
<span class="sd">        permutations : int, optional</span>
<span class="sd">            permutations to use for computation inference, by default 99</span>
<span class="sd">        keep : bool</span>
<span class="sd">            whether to store realized values of the statistic under permutations</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pointpats.spacetime.Knox</span>
<span class="sd">            a fitted Knox class</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s_coords</span><span class="p">,</span> <span class="n">t_coords</span> <span class="o">=</span> <span class="n">_spacetime_points_to_arrays</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">time_col</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">s_coords</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">[[</span><span class="n">time_col</span><span class="p">]],</span> <span class="n">delta</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">permutations</span><span class="p">,</span> <span class="n">keep</span><span class="p">)</span></div>
</div>



<span class="k">def</span> <span class="nf">_knox_local</span><span class="p">(</span><span class="n">s_coords</span><span class="p">,</span> <span class="n">t_coords</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="mi">99</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s_coords: array (n,2)</span>
<span class="sd">        spatial coordinates</span>
<span class="sd">    t_coords: array (n,1)</span>
<span class="sd">        temporal coordinates</span>
<span class="sd">    delta: numeric</span>
<span class="sd">        spatial threshold distance for neighbor relation</span>
<span class="sd">    tau: numeric</span>
<span class="sd">        temporal threshold distance for neighbor relation</span>
<span class="sd">    permutations: int</span>
<span class="sd">        number of permutations for conditional randomization inference</span>
<span class="sd">    keep: bool</span>
<span class="sd">        whether to store local statistics from the permtuations</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># think about passing in the global object as an option to avoid recomputing the trees</span>
    <span class="n">res</span> <span class="o">=</span> <span class="n">_knox</span><span class="p">(</span><span class="n">s_coords</span><span class="p">,</span> <span class="n">t_coords</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">permutations</span><span class="o">=</span><span class="n">permutations</span><span class="p">)</span>
    <span class="n">sneighbors</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">ns</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="s2">&quot;sneighbors&quot;</span><span class="p">])}</span>
    <span class="n">tneighbors</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">nt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="s2">&quot;tneighbors&quot;</span><span class="p">])}</span>

    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_coords</span><span class="p">)</span>
    <span class="n">ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="n">res</span><span class="p">[</span><span class="s2">&quot;nsti&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>  <span class="c1"># number of observed st_pairs for observation i</span>
    <span class="n">res</span><span class="p">[</span><span class="s2">&quot;nsi&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;sneighbors&quot;</span><span class="p">]]</span>
    <span class="n">res</span><span class="p">[</span><span class="s2">&quot;nti&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;tneighbors&quot;</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;st_pairs&quot;</span><span class="p">]:</span>
        <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="n">pair</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;nsti&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;nsti&quot;</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="n">nsti</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;nsti&quot;</span><span class="p">]</span>
    <span class="n">nsi</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;nsi&quot;</span><span class="p">]</span>
    <span class="n">res</span><span class="p">[</span><span class="s2">&quot;nti&quot;</span><span class="p">]</span>

    <span class="c1"># rather than do n*permutations, we reuse the permutations</span>
    <span class="c1"># ensuring that each permutation is conditional on a focal unit i</span>
    <span class="c1"># for each of the permutations we loop over i and swap labels between the</span>
    <span class="c1"># label at index i in the current permutation and the label at the index</span>
    <span class="c1"># assigned i in the permutation.</span>

    <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">exceedence</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">STI</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">permutations</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">permutations</span><span class="p">):</span>
            <span class="n">rids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">permutation</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
                <span class="n">rids_i</span> <span class="o">=</span> <span class="n">rids</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="c1"># set observed value of focal unit i</span>
                <span class="c1"># swap with value assigned to rids[i]</span>
                <span class="c1"># example</span>
                <span class="c1"># 0 1 2 (ids)</span>
                <span class="c1"># 2 0 1 (rids)</span>
                <span class="c1"># i=0</span>
                <span class="c1"># 0 2 1 (rids_i)</span>
                <span class="c1"># i=1</span>
                <span class="c1"># 2 1 0 (rids_i)</span>
                <span class="c1"># i=2</span>
                <span class="c1"># 1 0 2 (rids_i)</span>

                <span class="n">rids_i</span><span class="p">[</span><span class="n">rids</span> <span class="o">==</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">rids_i</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span>

                <span class="c1"># calculate local stat</span>
                <span class="n">rjs</span> <span class="o">=</span> <span class="p">[</span><span class="n">rids_i</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">sneighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
                <span class="n">tni</span> <span class="o">=</span> <span class="n">tneighbors</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">sti</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span> <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">rjs</span> <span class="k">if</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">tni</span><span class="p">]</span>
                <span class="n">count</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sti</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">&gt;=</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;nsti&quot;</span><span class="p">][</span><span class="n">i</span><span class="p">]:</span>
                    <span class="n">exceedence</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
                    <span class="n">STI</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">perm</span><span class="p">]</span> <span class="o">=</span> <span class="n">count</span>

        <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
            <span class="n">res</span><span class="p">[</span><span class="s2">&quot;sti_perm&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">STI</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;exceedence_pvalue&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">exceedence</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">permutations</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">res</span><span class="p">[</span><span class="s2">&quot;exceedences&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">exceedence</span>

    <span class="c1"># analytical inference</span>
    <span class="n">ntjis</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;tneighbors&quot;</span><span class="p">]]</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">hg_pvalues</span> <span class="o">=</span> <span class="p">[</span>
        <span class="mi">1</span> <span class="o">-</span> <span class="n">hypergeom</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">nsti</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">ntjis</span><span class="p">,</span> <span class="n">nsi</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="n">res</span><span class="p">[</span><span class="s2">&quot;hg_pvalues&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hg_pvalues</span><span class="p">)</span>

    <span class="c1"># identification of hot spots</span>

    <span class="n">adjlist</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="n">res</span><span class="p">[</span><span class="s2">&quot;st_pairs&quot;</span><span class="p">]:</span>
        <span class="n">adjlist</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
        <span class="n">adjlist</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">])</span>
    <span class="n">adjlist</span> <span class="o">=</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">adjlist</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbor&quot;</span><span class="p">])</span>
    <span class="n">adjlist</span> <span class="o">=</span> <span class="n">adjlist</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbor&quot;</span><span class="p">])</span>
    <span class="n">adjlist</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="n">adjlist</span><span class="p">[</span><span class="s2">&quot;orientation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">adjlist</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">focal</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">]</span>
        <span class="n">neighbor</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="s2">&quot;neighbor&quot;</span><span class="p">]</span>
        <span class="n">ft</span> <span class="o">=</span> <span class="n">t_coords</span><span class="p">[</span><span class="n">focal</span><span class="p">]</span>
        <span class="n">nt</span> <span class="o">=</span> <span class="n">t_coords</span><span class="p">[</span><span class="n">neighbor</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ft</span> <span class="o">&lt;</span> <span class="n">nt</span><span class="p">:</span>
            <span class="n">adjlist</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;lead&quot;</span>
        <span class="k">elif</span> <span class="n">ft</span> <span class="o">&gt;</span> <span class="n">nt</span><span class="p">:</span>
            <span class="n">adjlist</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;lag&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">adjlist</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">index</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;coincident&quot;</span>

    <span class="n">res</span><span class="p">[</span><span class="s2">&quot;stadjlist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">adjlist</span>
    <span class="k">return</span> <span class="n">res</span>


<div class="viewcode-block" id="KnoxLocal">
<a class="viewcode-back" href="../../generated/pointpats.KnoxLocal.html#pointpats.KnoxLocal">[docs]</a>
<span class="k">class</span> <span class="nc">KnoxLocal</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Local Knox statistics for space-time interactions</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    s_coords: array (nx2)</span>
<span class="sd">        spatial coordinates of point events</span>
<span class="sd">    t_coords: array (nx1)</span>
<span class="sd">        temporal coordinates of point events (floats or ints, not dateTime)</span>
<span class="sd">    delta: float</span>
<span class="sd">        spatial threshold defining distance below which pairs are spatial</span>
<span class="sd">        neighbors</span>
<span class="sd">    tau: float</span>
<span class="sd">        temporal threshold defining distance below which pairs are temporal</span>
<span class="sd">        neighbors</span>
<span class="sd">    permutations: int</span>
<span class="sd">        number of random permutations for inference</span>
<span class="sd">    keep: bool</span>
<span class="sd">        whether to store realized values of the statistic under permutations</span>
<span class="sd">    conditional: bool</span>
<span class="sd">        whether to include conditional permutation inference</span>
<span class="sd">    crit: float</span>
<span class="sd">      signifcance level for local statistics</span>
<span class="sd">    crs: str (optional)</span>
<span class="sd">        coordinate reference system string for s_coords</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    s_coords: array (nx2)</span>
<span class="sd">        spatial coordinates of point events</span>
<span class="sd">    t_coords: array (nx1)</span>
<span class="sd">        temporal coordinates of point events (floats or ints, not dateTime)</span>
<span class="sd">    delta: float</span>
<span class="sd">        spatial threshold defining distance below which pairs are spatial</span>
<span class="sd">        neighbors</span>
<span class="sd">    tau: float</span>
<span class="sd">        temporal threshold defining distance below which pairs are temporal</span>
<span class="sd">        neighbors</span>
<span class="sd">    permutations: int</span>
<span class="sd">        number of random permutations for inference</span>
<span class="sd">    keep: bool</span>
<span class="sd">        whether to store realized values of the statistic under permutations</span>
<span class="sd">    nst: int</span>
<span class="sd">        number of space-time pairs (global)</span>
<span class="sd">    p_poisson: float</span>
<span class="sd">        Analytical p-value under Poisson assumption (global)</span>
<span class="sd">    p_sim: float</span>
<span class="sd">        Pseudo p-value based on random permutations (global)</span>
<span class="sd">    expected: array</span>
<span class="sd">        Two-by-two array with expected counts under the null of no space-time</span>
<span class="sd">        interactions. [[NST, NS_], [NT_, N__]] where NST is the expected number</span>
<span class="sd">        of space-time pairs, NS_ is the expected number of spatial (but not also</span>
<span class="sd">        temporal) pairs, NT_ is the number of expected temporal (but not also</span>
<span class="sd">        spatial pairs), N__ is the number of pairs that are neighor spatial or</span>
<span class="sd">        temporal neighbors. (global)</span>
<span class="sd">    observed: array</span>
<span class="sd">        Same structure as expected with the observed pair classifications (global)</span>
<span class="sd">    sim: array</span>
<span class="sd">        Global statistics from permutations (if keep=True and keep=True) (global)</span>
<span class="sd">    p_sims: array</span>
<span class="sd">        Local psuedo p-values from conditional permutations (if permutations&gt;0)</span>
<span class="sd">    sims: array</span>
<span class="sd">        Local statistics from conditional permutations (if keep=True and</span>
<span class="sd">        permutations&gt;0)</span>
<span class="sd">    nsti: array</span>
<span class="sd">        Local statistics</span>
<span class="sd">    p_hypergeom: array</span>
<span class="sd">        Analytical p-values based on hypergeometric distribution</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    Technical details can be found in :cite:`Rogerson:2001`. The conditional</span>
<span class="sd">    permutation inference is unique to pysal.pointpats.</span>

<span class="sd">    Examples</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import libpysal</span>
<span class="sd">    &gt;&gt;&gt; path = libpysal.examples.get_path(&#39;burkitt.shp&#39;)</span>
<span class="sd">    &gt;&gt;&gt; import geopandas</span>
<span class="sd">    &gt;&gt;&gt; df = geopandas.read_file(path)</span>
<span class="sd">    &gt;&gt;&gt; from pointpats.spacetime import Knox</span>
<span class="sd">    &gt;&gt;&gt; import numpy</span>
<span class="sd">    &gt;&gt;&gt; numpy.random.seed(12345)</span>
<span class="sd">    &gt;&gt;&gt; local_knox = KnoxLocal(df[[&#39;X&#39;, &#39;Y&#39;]], df[[&quot;T&quot;]], delta=20, tau=5, keep=True)</span>
<span class="sd">    &gt;&gt;&gt; local_knox.statistic_.shape</span>
<span class="sd">    (188,)</span>
<span class="sd">    &gt;&gt;&gt; lres = local_knox</span>
<span class="sd">    &gt;&gt;&gt; gt0ids = numpy.where(lres.nsti&gt;0)</span>
<span class="sd">    &gt;&gt;&gt; gt0ids # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">    (array([ 25,  26,  30,  31,  35,  36,  41,  42,  46,  47,  51,  52, 102,</span>
<span class="sd">              103, 116, 118, 122, 123, 137, 138, 139, 140, 158, 159, 162, 163]),)</span>
<span class="sd">    &gt;&gt;&gt; lres.nsti[gt0ids]</span>
<span class="sd">    array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1., 1.,</span>
<span class="sd">           1., 1., 1., 1., 1., 1., 1., 1., 1.])</span>
<span class="sd">    &gt;&gt;&gt; lres.p_hypergeom[gt0ids]</span>
<span class="sd">    array([0.1348993 , 0.14220663, 0.07335085, 0.08400282, 0.1494317 ,</span>
<span class="sd">           0.21524073, 0.0175806 , 0.04599869, 0.17523687, 0.18209188,</span>
<span class="sd">           0.19111321, 0.16830444, 0.13734428, 0.14703242, 0.06796364,</span>
<span class="sd">           0.03192559, 0.13734428, 0.17523687, 0.12998154, 0.1933476 ,</span>
<span class="sd">           0.13244507, 0.13244507, 0.12502644, 0.14703242, 0.12502644,</span>
<span class="sd">           0.12998154])</span>
<span class="sd">    &gt;&gt;&gt; lres.p_sims[gt0ids]</span>
<span class="sd">    array([0.3 , 0.33, 0.11, 0.17, 0.3 , 0.42, 0.06, 0.06, 0.33, 0.34, 0.36,</span>
<span class="sd">           0.38, 0.3 , 0.29, 0.41, 0.19, 0.31, 0.39, 0.18, 0.39, 0.48, 0.41,</span>
<span class="sd">           0.22, 0.41, 0.39, 0.32])</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="KnoxLocal.__init__">
<a class="viewcode-back" href="../../generated/pointpats.KnoxLocal.html#pointpats.KnoxLocal.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">s_coords</span><span class="p">,</span>
        <span class="n">t_coords</span><span class="p">,</span>
        <span class="n">delta</span><span class="p">,</span>
        <span class="n">tau</span><span class="p">,</span>
        <span class="n">permutations</span><span class="o">=</span><span class="mi">99</span><span class="p">,</span>
        <span class="n">keep</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">crit</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
        <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t_coords</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;t_coords  should be numpy.ndarray type&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s_coords</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;s_coords  should be numpy.ndarray type&quot;</span><span class="p">)</span>
        <span class="n">n_s</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">s_coords</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">rangeids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_s</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;s_coords shape required to be nx2&quot;</span><span class="p">)</span>
        <span class="n">n_t</span><span class="p">,</span> <span class="n">k</span> <span class="o">=</span> <span class="n">t_coords</span><span class="o">.</span><span class="n">shape</span>
        <span class="k">if</span> <span class="n">n_s</span> <span class="o">!=</span> <span class="n">n_t</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;t_coords and s_coords need to be same length&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_s</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;`ids` must have the same length as the inputs&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ids</span> <span class="o">=</span> <span class="n">rangeids</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ids</span> <span class="o">=</span> <span class="n">ids</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">s_coords</span> <span class="o">=</span> <span class="n">s_coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">t_coords</span> <span class="o">=</span> <span class="n">t_coords</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">delta</span> <span class="o">=</span> <span class="n">delta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tau</span> <span class="o">=</span> <span class="n">tau</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">permutations</span> <span class="o">=</span> <span class="n">permutations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keep</span> <span class="o">=</span> <span class="n">keep</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crit</span> <span class="o">=</span> <span class="n">crit</span>
        <span class="n">results</span> <span class="o">=</span> <span class="n">_knox_local</span><span class="p">(</span><span class="n">s_coords</span><span class="p">,</span> <span class="n">t_coords</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">permutations</span><span class="p">,</span> <span class="n">keep</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjlist</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;stadjlist&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nst</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s2">&quot;nst&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_sim</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;p_value_sim&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sim</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;sti_perm&quot;</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">p_poisson</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;p_value_poisson&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">observed</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;observed&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expected</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;expected&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">p_hypergeom</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;hg_pvalues&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">p_sims</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;exceedence_pvalue&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">keep</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sims</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;sti_perm&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nsti</span> <span class="o">=</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;nsti&quot;</span><span class="p">]</span>
        <span class="c1"># self.hotspots = results[&quot;hotspots&quot;]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_crs</span> <span class="o">=</span> <span class="n">crs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">statistic_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsti</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_id_map</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">rangeids</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ids</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjlist</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjlist</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id_map</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">adjlist</span><span class="p">[</span><span class="s2">&quot;neighbor&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjlist</span><span class="p">[</span><span class="s2">&quot;neighbor&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_id_map</span><span class="p">)</span>
        <span class="c1"># reconstruct df</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">points_from_xy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">s_coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">s_coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">geom</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_crs</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_ids</span><span class="p">)</span>
        <span class="n">_gdf</span><span class="p">[</span><span class="s2">&quot;time&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">t_coords</span>
        <span class="k">if</span> <span class="n">permutations</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">_gdf</span><span class="p">[</span><span class="s2">&quot;p_sim&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_sims</span>
        <span class="n">_gdf</span><span class="p">[</span><span class="s2">&quot;p_hypergeom&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_hypergeom</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_gdf_static</span> <span class="o">=</span> <span class="n">_gdf</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">_gdf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gdf_static</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

<div class="viewcode-block" id="KnoxLocal.from_dataframe">
<a class="viewcode-back" href="../../generated/pointpats.KnoxLocal.html#pointpats.KnoxLocal.from_dataframe">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dataframe</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">dataframe</span><span class="p">,</span>
        <span class="n">time_col</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">delta</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">tau</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">permutations</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">99</span><span class="p">,</span>
        <span class="n">keep</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute a set of local Knox statistics from a dataframe of Point observations</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dataframe : geopandas.GeoDataFrame</span>
<span class="sd">            dataframe holding observations. Should be in a projected coordinate system</span>
<span class="sd">            with geometries stored as Points</span>
<span class="sd">        time_col : str</span>
<span class="sd">            column in the dataframe storing the time values (integer coordinate)</span>
<span class="sd">            for each observation. For example if the observations are stored with</span>
<span class="sd">            a timestamp, the time_col should be converted to a series of integers</span>
<span class="sd">            representing, e.g. hours, days, seconds, etc.</span>
<span class="sd">        delta : int</span>
<span class="sd">            delta parameter defining the spatial neighbor threshold measured in the</span>
<span class="sd">            same units as the dataframe CRS</span>
<span class="sd">        tau : int</span>
<span class="sd">            tau parameter defining the temporal neihgbor threshold (in the units</span>
<span class="sd">            measured by `time_col`)</span>
<span class="sd">        permutations : int, optional</span>
<span class="sd">            permutations to use for computational inference, by default 99</span>
<span class="sd">        keep : bool</span>
<span class="sd">            whether to store realized values of the statistic under permutations</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pointpats.spacetime.LocalKnox</span>
<span class="sd">            a fitted KnoxLocal class</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s_coords</span><span class="p">,</span> <span class="n">t_coords</span> <span class="o">=</span> <span class="n">_spacetime_points_to_arrays</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">time_col</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span>
            <span class="n">s_coords</span><span class="p">,</span>
            <span class="n">t_coords</span><span class="p">,</span>
            <span class="n">delta</span><span class="p">,</span>
            <span class="n">tau</span><span class="p">,</span>
            <span class="n">permutations</span><span class="p">,</span>
            <span class="n">keep</span><span class="p">,</span>
            <span class="n">crs</span><span class="o">=</span><span class="n">dataframe</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span>
            <span class="n">ids</span><span class="o">=</span><span class="n">dataframe</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="KnoxLocal.hotspots">
<a class="viewcode-back" href="../../generated/pointpats.KnoxLocal.html#pointpats.KnoxLocal.hotspots">[docs]</a>
    <span class="k">def</span> <span class="nf">hotspots</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crit</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">inference</span><span class="o">=</span><span class="s2">&quot;permutation&quot;</span><span class="p">,</span> <span class="n">keep_neighbors</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Table of significant space-time clusters that define local hotspots.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crit : float, optional</span>
<span class="sd">            critical value for statistical inference, by default 0.05</span>
<span class="sd">        inference : str, optional</span>
<span class="sd">            whether p-values should use permutation or analutical inference, by default</span>
<span class="sd">            &quot;permutation&quot;</span>
<span class="sd">        keep_neighbors: bool</span>
<span class="sd">            whether to included nonsignificant members of hotspots. While these</span>
<span class="sd">            observations are not themselves significant, these still define the spatial</span>
<span class="sd">            extent of the cluster, and the the focal observation cannot become</span>
<span class="sd">            significant without their presence. If True, return all members of a</span>
<span class="sd">            significant hotspot, else return only the significant locations</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            dataframe of significant hotspots</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            if `inference` is not in {&#39;permutation&#39;, &#39;analytic&#39;}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">inference</span> <span class="o">==</span> <span class="s2">&quot;permutation&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;p_sim&quot;</span><span class="p">):</span>
                <span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Pseudo-p values not availalable. Permutation-based p-values require &quot;</span>
                    <span class="s2">&quot;fitting the KnoxLocal class using `permutations` set to a large &quot;</span>
                    <span class="s2">&quot;number. Using analytic p-values instead&quot;</span><span class="p">,</span>
                    <span class="n">stacklevel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">col</span> <span class="o">=</span> <span class="s2">&quot;p_hypergeom&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">col</span> <span class="o">=</span> <span class="s2">&quot;p_sim&quot;</span>
        <span class="k">elif</span> <span class="n">inference</span> <span class="o">==</span> <span class="s2">&quot;analytic&quot;</span><span class="p">:</span>
            <span class="n">col</span> <span class="o">=</span> <span class="s2">&quot;p_hypergeom&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;inference must be either `permutation` or `analytic`&quot;</span><span class="p">)</span>
        <span class="c1"># determine hot spots</span>
        <span class="n">pdf_sig</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gdf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_gdf</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">crit</span><span class="p">][[</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
            <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="s2">&quot;pvalue&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="s2">&quot;focal_time&quot;</span><span class="p">}</span>
        <span class="p">)</span>

        <span class="c1"># if keep_neighbors, we want to include a &#39;cluster&#39; column denoting which</span>
        <span class="c1"># cluster nonsig observations belong to. Need to use a graph for that</span>
        <span class="n">temp_neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjlist</span><span class="p">[</span>
            <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">adjlist</span><span class="o">.</span><span class="n">focal</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">pdf_sig</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">))</span>
            <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjlist</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">pdf_sig</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">pdf_sig</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">pdf_sig</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gdf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_gdf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">temp_neighbors</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

                <span class="p">][[</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
                <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="s2">&quot;pvalue&quot;</span><span class="p">,</span> <span class="s2">&quot;time&quot;</span><span class="p">:</span> <span class="s2">&quot;focal_time&quot;</span><span class="p">}</span>
            <span class="p">)</span>
        <span class="p">])</span>

        <span class="n">pdf_sig</span> <span class="o">=</span> <span class="n">pdf_sig</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">temp_neighbors</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;outer&#39;</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;focal&quot;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># significant focals can be neighbors of others (dupes)</span>
        <span class="n">pdf_sig</span> <span class="o">=</span> <span class="n">pdf_sig</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;focal&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">first</span><span class="p">()</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">graph</span> <span class="o">=</span> <span class="n">Graph</span><span class="o">.</span><span class="n">from_adjacency</span><span class="p">(</span><span class="n">pdf_sig</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">pdf_sig</span><span class="p">[</span><span class="s2">&quot;cluster&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">component_labels</span><span class="o">.</span><span class="n">values</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">keep_neighbors</span> <span class="p">:</span>
            <span class="n">pdf_sig</span> <span class="o">=</span> <span class="n">pdf_sig</span><span class="p">[</span><span class="n">pdf_sig</span><span class="o">.</span><span class="n">pvalue</span><span class="o">&lt;=</span><span class="n">crit</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gdf</span><span class="p">[[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">pdf_sig</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;focal&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="KnoxLocal.plot">
<a class="viewcode-back" href="../../generated/pointpats.KnoxLocal.html#pointpats.KnoxLocal.plot">[docs]</a>
    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">colors</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;focal&quot;</span><span class="p">:</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbor&quot;</span><span class="p">:</span> <span class="s2">&quot;yellow&quot;</span><span class="p">,</span> <span class="s2">&quot;nonsig&quot;</span><span class="p">:</span> <span class="s2">&quot;grey&quot;</span><span class="p">},</span>
        <span class="n">crit</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
        <span class="n">inference</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;permutation&quot;</span><span class="p">,</span>
        <span class="n">point_kwargs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">plot_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">edge_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span><span class="p">,</span>
        <span class="n">edge_kwargs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;plot hotspots</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        colors : dict, optional</span>
<span class="sd">            mapping of colors to hotspot values, by default</span>
<span class="sd">            {&quot;focal&quot;: &quot;red&quot;, &quot;neighbor&quot;: &quot;yellow&quot;, &quot;nonsig&quot;: &quot;grey&quot;}</span>
<span class="sd">        crit : float, optional</span>
<span class="sd">            critical value for assessing statistical sgifnicance, by default 0.05</span>
<span class="sd">        inference : str, optional</span>
<span class="sd">            whether to use permutation or analytic inference, by default &quot;permutation&quot;</span>
<span class="sd">        point_kwargs : dict, optional</span>
<span class="sd">            additional keyword arguments passsed to point plot, by default None</span>
<span class="sd">        plot_edges : bool, optional</span>
<span class="sd">            whether to plot edges connecting members of the same hotspot subgraph,</span>
<span class="sd">            by default True</span>
<span class="sd">        edge_color : str, optional</span>
<span class="sd">            color of edges when plot_edges is True, by default &#39;black&#39;</span>
<span class="sd">        edge_kwargs : dict, optional</span>
<span class="sd">            additional keyword arguments passsed to edge plot, by default None</span>
<span class="sd">        ax : matplotlib.axes.Axes, optional</span>
<span class="sd">            axes object on which to create the plot, by default None</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        matplotlib.axes.Axes</span>
<span class="sd">            plot of local space-time hotspots</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">point_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">point_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">edge_kwargs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">edge_kwargs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">g</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="s2">&quot;nonsig&quot;</span><span class="p">]</span>
        <span class="n">g</span><span class="p">[</span><span class="s2">&quot;pvalue&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_hypergeom</span>
        <span class="k">if</span> <span class="n">inference</span> <span class="o">==</span> <span class="s2">&quot;permutation&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;p_sims&quot;</span><span class="p">):</span>
                <span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Pseudo-p values not availalable. Permutation-based p-values require &quot;</span>
                    <span class="s2">&quot;fitting the KnoxLocal class using `permutations` set to a large &quot;</span>
                    <span class="s2">&quot;number. Using analytic p-values instead&quot;</span>
                <span class="p">)</span>
                <span class="n">g</span><span class="p">[</span><span class="s2">&quot;pvalue&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_hypergeom</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span><span class="p">[</span><span class="s2">&quot;pvalue&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_sims</span>
        <span class="k">elif</span> <span class="n">inference</span> <span class="o">==</span> <span class="s2">&quot;analytic&quot;</span><span class="p">:</span>
            <span class="n">g</span><span class="p">[</span><span class="s2">&quot;pvalue&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_hypergeom</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;inference must be either `permutation` or `analytic`&quot;</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">pvalue</span> <span class="o">&lt;=</span> <span class="n">crit</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">adjlist</span><span class="o">.</span><span class="n">focal</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">mask</span><span class="p">)]</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>
        <span class="n">g</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">neighbors</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="s2">&quot;neighbor&quot;</span><span class="p">]</span>
        <span class="n">g</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">pvalue</span> <span class="o">&lt;=</span> <span class="n">crit</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">]</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">colors</span><span class="p">[</span><span class="s2">&quot;nonsig&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="s2">&quot;nonsig&quot;</span><span class="p">],</span> <span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span> <span class="o">**</span><span class="n">point_kwargs</span>
        <span class="p">)</span>
        <span class="n">g</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">colors</span><span class="p">[</span><span class="s2">&quot;neighbor&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
            <span class="n">ax</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="s2">&quot;neighbor&quot;</span><span class="p">],</span> <span class="o">**</span><span class="n">point_kwargs</span>
        <span class="p">)</span>
        <span class="n">g</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">colors</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">],</span> <span class="o">**</span><span class="n">point_kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_edges</span><span class="p">:</span>
            <span class="c1"># edges between hotspot and st-neighbors</span>
            <span class="n">ghs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hotspots</span><span class="p">(</span><span class="n">crit</span><span class="o">=</span><span class="n">crit</span><span class="p">,</span> <span class="n">inference</span><span class="o">=</span><span class="n">inference</span><span class="p">)</span>
            <span class="n">ghs</span> <span class="o">=</span> <span class="n">ghs</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
            <span class="n">origins</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ghs</span><span class="o">.</span><span class="n">focal</span><span class="p">]</span><span class="o">.</span><span class="n">geometry</span>
            <span class="n">destinations</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ghs</span><span class="o">.</span><span class="n">neighbor</span><span class="p">]</span><span class="o">.</span><span class="n">geometry</span>
            <span class="n">ods</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">destinations</span><span class="p">)</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">([</span><span class="n">LineString</span><span class="p">(</span><span class="n">od</span><span class="p">)</span> <span class="k">for</span> <span class="n">od</span> <span class="ow">in</span> <span class="n">ods</span><span class="p">],</span> <span class="n">crs</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">edge_color</span><span class="p">,</span> <span class="o">**</span><span class="n">edge_kwargs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">m</span></div>


<div class="viewcode-block" id="KnoxLocal.explore">
<a class="viewcode-back" href="../../generated/pointpats.KnoxLocal.html#pointpats.KnoxLocal.explore">[docs]</a>
    <span class="k">def</span> <span class="nf">explore</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">crit</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
        <span class="n">inference</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;permutation&quot;</span><span class="p">,</span>
        <span class="n">radius</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">style_kwds</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">tiles</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;CartoDB Positron&quot;</span><span class="p">,</span>
        <span class="n">plot_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">edge_weight</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
        <span class="n">edge_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span><span class="p">,</span>
        <span class="n">colors</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;focal&quot;</span><span class="p">:</span> <span class="s2">&quot;red&quot;</span><span class="p">,</span> <span class="s2">&quot;neighbor&quot;</span><span class="p">:</span> <span class="s2">&quot;yellow&quot;</span><span class="p">,</span> <span class="s2">&quot;nonsig&quot;</span><span class="p">:</span> <span class="s2">&quot;grey&quot;</span><span class="p">},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interactive plotting for space-time hotspots.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        crit : float, optional</span>
<span class="sd">            critical value for statistical inference, by default 0.05</span>
<span class="sd">        inference : str, optional</span>
<span class="sd">            which p-value to use for determining hotspots. Either &quot;permutation&quot; or</span>
<span class="sd">            &quot;analytic&quot;, by default &quot;permutation&quot;</span>
<span class="sd">        radius : int, optional</span>
<span class="sd">            radius of the circlemarker plotted by folium, passed to</span>
<span class="sd">            geopandas.GeoDataFrame.explore style_kwds as a convenience. Ignored if</span>
<span class="sd">            `style_kwds` is passed directly, by default 5</span>
<span class="sd">        style_kwds : dict, optional</span>
<span class="sd">            additional style kewords passed to GeoDataFrame.explore, by default None</span>
<span class="sd">        tiles : str, optional</span>
<span class="sd">            tileset passed to GeoDataFrame.explore `tiles` argument, by default</span>
<span class="sd">            &quot;CartoDB Positron&quot;</span>
<span class="sd">        plot_edges : bool, optional</span>
<span class="sd">            Whether to include lines drawn between members of a singnificant hotspot, by</span>
<span class="sd">            default True</span>
<span class="sd">        edge_weight : int, optional</span>
<span class="sd">            line thickness when `plot_edges=True`, by default 2</span>
<span class="sd">        edge_color : str, optional</span>
<span class="sd">            color of line when `plot_edges=True`, by default &quot;black&quot;</span>
<span class="sd">        colors : dict, optional</span>
<span class="sd">            mapping of observation type to color,</span>
<span class="sd">            by default {&quot;focal&quot;: &quot;red&quot;, &quot;neighbor&quot;: &quot;yellow&quot;, &quot;nonsig&quot;: &quot;grey&quot;}</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        folium.Map</span>
<span class="sd">            an interactive map showing locally-significant spacetime hotspots</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">style_kwds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">style_kwds</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;radius&quot;</span><span class="p">:</span> <span class="n">radius</span><span class="p">}</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_gdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="n">g</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="s2">&quot;nonsig&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">inference</span> <span class="o">==</span> <span class="s2">&quot;permutation&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;p_sims&quot;</span><span class="p">):</span>
                <span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Pseudo-p values not availalable. Permutation-based p-values require &quot;</span>
                    <span class="s2">&quot;fitting the KnoxLocal class using `permutations` set to a large &quot;</span>
                    <span class="s2">&quot;number. Using analytic p-values instead&quot;</span>
                <span class="p">)</span>
                <span class="n">g</span><span class="p">[</span><span class="s2">&quot;pvalue&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_hypergeom</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">g</span><span class="p">[</span><span class="s2">&quot;pvalue&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_sims</span>
        <span class="k">elif</span> <span class="n">inference</span> <span class="o">==</span> <span class="s2">&quot;analytic&quot;</span><span class="p">:</span>
            <span class="n">g</span><span class="p">[</span><span class="s2">&quot;pvalue&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_hypergeom</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;inference must be either `permutation` or `analytic`&quot;</span><span class="p">)</span>

        <span class="n">mask</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">pvalue</span> <span class="o">&lt;=</span> <span class="n">crit</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
        <span class="n">neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjlist</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">adjlist</span><span class="o">.</span><span class="n">focal</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">mask</span><span class="p">)]</span><span class="o">.</span><span class="n">neighbor</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="c1"># this is clunky, but enforces plotting order so significance is prioritized</span>
        <span class="n">g</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">neighbors</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="s2">&quot;neighbor&quot;</span><span class="p">]</span>
        <span class="n">g</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">pvalue</span> <span class="o">&lt;=</span> <span class="n">crit</span><span class="p">,</span> <span class="s2">&quot;color&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">]</span>
        <span class="n">nbs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">adjlist</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;focal&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="nb">list</span><span class="p">)[</span><span class="s2">&quot;neighbor&quot;</span><span class="p">]</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">nbs</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;index&quot;</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

        <span class="n">m</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">colors</span><span class="p">[</span><span class="s2">&quot;nonsig&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">explore</span><span class="p">(</span>
            <span class="n">color</span><span class="o">=</span><span class="s2">&quot;grey&quot;</span><span class="p">,</span> <span class="n">style_kwds</span><span class="o">=</span><span class="n">style_kwds</span><span class="p">,</span> <span class="n">tiles</span><span class="o">=</span><span class="n">tiles</span>
        <span class="p">)</span>
        <span class="n">blues</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">colors</span><span class="p">[</span><span class="s2">&quot;neighbor&quot;</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">blues</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;empty neighbor set.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">blues</span><span class="o">.</span><span class="n">explore</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="s2">&quot;neighbor&quot;</span><span class="p">],</span> <span class="n">style_kwds</span><span class="o">=</span><span class="n">style_kwds</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="n">g</span><span class="o">.</span><span class="n">color</span> <span class="o">==</span> <span class="n">colors</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">explore</span><span class="p">(</span>
            <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="s2">&quot;focal&quot;</span><span class="p">],</span> <span class="n">style_kwds</span><span class="o">=</span><span class="n">style_kwds</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">plot_edges</span><span class="p">:</span>
            <span class="c1"># edges between hotspot and st-neighbors</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;index&quot;</span><span class="p">)</span>
            <span class="n">ghs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hotspots</span><span class="p">(</span><span class="n">crit</span><span class="o">=</span><span class="n">crit</span><span class="p">,</span> <span class="n">inference</span><span class="o">=</span><span class="n">inference</span><span class="p">)</span>
            <span class="n">ghs</span> <span class="o">=</span> <span class="n">ghs</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span>
            <span class="n">origins</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ghs</span><span class="o">.</span><span class="n">focal</span><span class="p">]</span><span class="o">.</span><span class="n">geometry</span>
            <span class="n">destinations</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">ghs</span><span class="o">.</span><span class="n">neighbor</span><span class="p">]</span><span class="o">.</span><span class="n">geometry</span>
            <span class="n">ods</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">origins</span><span class="p">,</span> <span class="n">destinations</span><span class="p">)</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoSeries</span><span class="p">([</span><span class="n">LineString</span><span class="p">(</span><span class="n">od</span><span class="p">)</span> <span class="k">for</span> <span class="n">od</span> <span class="ow">in</span> <span class="n">ods</span><span class="p">],</span> <span class="n">crs</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">explore</span><span class="p">(</span><span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">edge_color</span><span class="p">,</span> <span class="n">style_kwds</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="n">edge_weight</span><span class="p">})</span>

        <span class="k">return</span> <span class="n">m</span></div>


    <span class="k">def</span> <span class="nf">_gdfhs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">crit</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">inference</span><span class="o">=</span><span class="s2">&quot;permutation&quot;</span><span class="p">):</span>
        <span class="c1"># merge df with self.hotspots</span>
        <span class="k">return</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_gdf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">hotspots</span><span class="p">(</span><span class="n">crit</span><span class="o">=</span><span class="n">crit</span><span class="p">,</span> <span class="n">inference</span><span class="o">=</span><span class="n">inference</span><span class="p">),</span>
                <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;focal&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span></div>



<span class="k">def</span> <span class="nf">_spacetime_points_to_arrays</span><span class="p">(</span><span class="n">dataframe</span><span class="p">,</span> <span class="n">time_col</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;convert long-form geodataframe into arrays for kdtree</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    dataframe : geopandas.GeoDataFrame</span>
<span class="sd">        geodataframe with point geometries</span>
<span class="sd">    time_col : str</span>
<span class="sd">        name of the column on dataframe that stores time values</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        two numpy arrays holding spatial coodinates s_coords (n,2)</span>
<span class="sd">        and temporal coordinates t_coords (n,1)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">warn</span><span class="p">(</span>
            <span class="s2">&quot;There is no CRS set on the dataframe. The KDTree will assume coordinates &quot;</span>
            <span class="s2">&quot;are stored in Euclidean distances&quot;</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">is_geographic</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The input dataframe must be in a projected coordinate system.&quot;</span>
            <span class="p">)</span>

    <span class="k">assert</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">geom_type</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span> <span class="o">==</span> <span class="p">[</span>
        <span class="s2">&quot;Point&quot;</span>
    <span class="p">],</span> <span class="s2">&quot;The Knox statistic is only defined for Point geometries&quot;</span>

    <span class="c1"># kdtree wont operate on datetime</span>
    <span class="k">if</span> <span class="n">is_numeric_dtype</span><span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The time values must be stored as &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;a numeric dtype but the column </span><span class="si">{</span><span class="n">time_col</span><span class="si">}</span><span class="s2"> is stored as &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">dataframe</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">s_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dataframe</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">x</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">y</span><span class="o">.</span><span class="n">values</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>
    <span class="n">t_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">(</span><span class="n">dataframe</span><span class="p">[</span><span class="n">time_col</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">s_coords</span><span class="p">,</span> <span class="n">t_coords</span>
</pre></div>

    </div>
      
  </div>
</div>
<footer class="footer">
  <div class="container">
    <p class="pull-right">
      <a href="#">Back to top</a>
      
        <br/>
        
      
    </p>
    <p>
        &copy; Copyright 2018-, pysal developers.<br/>
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 8.0.2.<br/>
    </p>
  </div>
</footer>
  </body>
</html>